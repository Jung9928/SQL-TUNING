* 시작 전, 용어 정리
- 라이브러리 캐시 : SQL 파싱 -> 최적화 -> 로우 소스 생성 과정을 거쳐 생성된 내부 프로시저를 반복 재사용할 수 있도록 
                   캐싱해 두는 메모리 공간. (즉, 한 번만 생성해놓고 버퍼에 저장하여 가져다 쓰는 개념)
                   
- 소프트 파싱 : 사용자가 SQL문을 전달하면 DBMS가 파싱 후, 해당 SQL이 라이브러리 캐시에 존재하는지 체크.
               존재하면 바로 SQL 실행하는 과정
                   
- 하드 파싱   : 라이브러리 캐시에 존재하지 않아 로우 소스 생성 단계까지 모두 거치는 것 -> 하드 파싱
                   
- 하드파싱은 매우 소모적인 작업. -> CPU 많이 소비 -> 실행 COST가 높음 -> 라이브러리 캐시가 필요한 이유

* 이름없는 SQL 문제
- 사용자 정의 함수 / 프로시저, 트리거, 패키지 ... etc --> 생성할 떄 부터 이름을 갖는다.
  컴파일한 상태로 딕셔너리에 저장. 사용자가 삭제하지 않는 한 영구 보관.
  실행할 때, 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용.
 
- SQL은 이름이 따로 존재X --> 전체 SQL 텍스트가 이름 역할을 수행 (딕셔너리에 저장하지도 않음)
  처음 실행할 때, 최적화 과정을 거친 후, 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재하여 여러 사용자가 공유&재사용.
  캐시 공간이 부족하면 버려졌다가 다음에 다시 실행 시, 똑같은 최적화 과정을 거쳐 캐시에 적재.
  
  사용자 정의 함수/프로시저는 내용을 수정해도 이름이 변하지 않으므로 사용할 때 마다 재생성 X
  SQL은 이름이 따로 없고 구문 자체가 식별자 역할을 수행하므로 대소문자, 공백, SQL 텍스트 중 작은 것 하나라도 변경이 있다면
  내부적으로 객체를 새로 생성해서 SQL 텍스트를 저장.
  
- 특히, 개발과정에선 SQL이 수시로 변경되고 일회성 SQL도 많으며 이러한 SQL이 모두 저장된다면 DBMS에 해당 SQL을 라이브러리 캐시에서 
  찾을 때 COST가 너무 높아 비효율적. --> 그래서 오라클, SQL Server는 DBMS가 SQL을 영구저장하지 않는 방향으로 설계됨.
 

* 공유 가능 SQL
```SQL
아래는 SQL 결과는 같지만 모두 다른 SQL로 취급됨.

SELECT * FROM emp WHERE empno = 7900;
select * from EMP where EMPNO = 7900;
select * from emp where empno = 7900;
select * from emp where empno = 7900 ;
select * from emp where empno = 7900  ;
select * from scott.emp where empno = 7900;
select /* comment */ * from emp where empno = 7900;
select /*+ first_rows */ * from emp where empno = 7900;
```



                  
                   
