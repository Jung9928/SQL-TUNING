* SQL이 느린이유
- 디스크 I/O 때문 --> I/O 튜닝이 곧 SQL 튜닝.
    - I/O Call 속도는 Single Block I/O 기준, 평균 10ms 정도
    - SQL이 Single Block I/O 방식으로 많은 양의 데이터 블록을 read 할 경우, 많은 시간이 필요.
      I/O 튜닝이 안된 시스템일 경우, 수 많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call로 인해
      디스크 경합 발생.
      

* 데이터베이스 저장 구조
<img src="https://github.com/Jung9928/SQL-TUNING/assets/45419456/0571da4c-8928-4d4b-b88f-0e3053ecdddc" width="50%" height="50%" />


1) 데이터 저장을 위해 테이블스페이스를 생성.
  - 테이블 스페이스 : 세그먼트를 담는 컨테이너, 여러 개의 데이터파일(디스크 상의 물리적인 OS파일)로 구성.
  - 세그먼트 : 테이블, 인덱스처럼 저장공간이 필요한 오브젝트. 
    (테이블, 인덱스 생성 시, 데이터를 어떤 테이블스페이스에 저장할 지 지정.)

    세그먼트는 여러 익스텐트로 구성. 파티션 구조가 아니라면 테이블, 인덱스도 하나의 세그먼트.
    파티션 구조라면 각 파티션이 하나의 세그먼트. 
    LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블이 아닌 다른 별도 공간에 값을 저장.
    
  - 익스텐트 : 공간 확장 단위. 테이블 or 인덱스에 데이터 입력 시, 공간이 부족할 경우 해당 오브젝트가 속한 테이블 스페이스로부터 
               익스텐트를 추가로 할당받는다.<br/><br/> 
               익스텐트는 연속된 블록들의 집합이기도 함.
               익스텐트 단위로 공간을 확장하더라도 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록.
               DBMS마다 명칭의 차이가 있음. (블록 or 페이지)<br/><br/>
               한 블록은 하나의 테이블이 독점. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드.
               하나의 익스텐트도 하나의 테이블이 독점. 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록.
               세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있음 -> 서로 다른 데이터파일에 위치할 가능성이 높음.<br/><br/>
               하나의 테이블스페이스를 여러 데이터파일로 구성 시, 파일 경합을 줄이기 위해 DBMS가 데이터를 가능한 한 여러 데이터파일로 분산해서
               저장하기 때문.
               익스텐트 내 블록은 서로 인접한 연속 공간이지만 익스텐트 끼리는 연속된 공간이 아님.
```SQL
/* 세그먼트에 할당된 익스텐트 목록 조회 */

SELECT SEGMENT_TYPE
     , TABLESPACE_NAME
     , EXTENT_ID
     , FILE_ID
     , BLOCK_ID
     , BLOCKS
  FROM DBA_EXTENTS
 WHERE OWNER = USER
   AND SEGMENT_NAME = 'MY_SEGMENT'
 ORDER BY EXTENT_ID
;
```

2) Single Block I/O vs MultiBlock I/O
- 캐시에서 찾지 못한 데이터 블록 I/O call을 통해 디스크 -> DB 버퍼캐시로 적재 후, READ
  I/O Call 할 때, 한 번에 한 블록(Single Block I/O) 씩 요청하기도 하고 여러 블록(Multi Block I/O)씩 요청해서 메모리에 적재하기도 함.

- 인덱스 사용 시, 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용.
- 인덱스는 소량 데이터 READ 시, 주로 사용 -> Single Block I/O 방식이 효율적.
  * Single Block I/O 방식이 효율적인 경우
    - 인덱스 루트 블록 READ 시
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록 READ 시
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록 READ 시
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록 READ 시

  * MultiBlock I/O 방식이 효율적인 경우
    - 인덱스 이용하지 않고 테이블 전체 스캔 시 (테이블이 클수록 MultiBlock I/O 단위도 크면 좋음) -> 프로세스 IDLE 횟수 감소
      

