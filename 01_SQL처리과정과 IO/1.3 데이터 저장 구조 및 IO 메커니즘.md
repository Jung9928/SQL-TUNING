* SQL이 느린이유
- 디스크 I/O 때문 --> I/O 튜닝이 곧 SQL 튜닝.
    - I/O Call 속도는 Single Block I/O 기준, 평균 10ms 정도
    - SQL이 Single Block I/O 방식으로 많은 양의 데이터 블록을 read 할 경우, 많은 시간이 필요.
      I/O 튜닝이 안된 시스템일 경우, 수 많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call로 인해
      디스크 경합 발생.
      

* 데이터베이스 저장 구조
<img src="https://github.com/Jung9928/SQL-TUNING/assets/45419456/0571da4c-8928-4d4b-b88f-0e3053ecdddc" width="50%" height="50%" />


1) 데이터 저장을 위해 테이블스페이스를 생성.
  - 테이블 스페이스 : 세그먼트를 담는 컨테이너, 여러 개의 데이터파일(디스크 상의 물리적인 OS파일)로 구성.
  - 세그먼트 : 테이블, 인덱스처럼 저장공간이 필요한 오브젝트. 
    (테이블, 인덱스 생성 시, 데이터를 어떤 테이블스페이스에 저장할 지 지정.)

    세그먼트는 여러 익스텐트로 구성. 파티션 구조가 아니라면 테이블, 인덱스도 하나의 세그먼트.
    파티션 구조라면 각 파티션이 하나의 세그먼트. 
    LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블이 아닌 다른 별도 공간에 값을 저장.
    
  - 익스텐트 : 공간 확장 단위. 테이블 or 인덱스에 데이터 입력 시, 공간이 부족할 경우 해당 오브젝트가 속한 테이블 스페이스로부터 
               익스텐트를 추가로 할당받는다. 
               익스텐트는 연속된 블록들의 집합이기도 함.
               익스텐트 단위로 공간을 확장하더라도 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록.
               DBMS마다 명칭의 차이가 있음. (블록 or 페이지)
               한 블록은 하나의 테이블이 독점. 즉, 한 블록에 저장된 레코드는 모두 같은 테이블 레코드.
               하나의 익스텐트도 하나의 테이블이 독점. 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록.
               세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있음 -> 서로 다른 데이터파일에 위치할 가능성이 높음.
               하나의 테이블스페이스를 여러 데이터파일로 구성 시, 파일 경합을 줄이기 위해 DBMS가 데이터를 가능한 한 여러 데이터파일로 분산해서
               저장하기 때문.
               익스텐트 내 블록은 서로 인접한 연속 공간이지만 익스텐트 끼리는 연속된 공간이 아님.
               
               ```SQL
               /* 세그먼트에 할당된 익스텐트 목록 조회 */
               
               SELECT SEGMENT_TYPE
                    , TABLESPACE_NAME
                    , EXTENT_ID
                    , FILE_ID
                    , BLOCK_ID
                    , BLOCKS
                 FROM DBA_EXTENS
                WHERE OWNER = USER
                  AND SEGMENT_NAME = 'MY_SEGMENT'
                ORDER BY EXTENT_ID
               ;
               ```
               

